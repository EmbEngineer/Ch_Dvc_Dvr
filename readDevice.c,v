head	1.10;
access;
symbols;
locks
	root:1.10; strict;
comment	@ * @;


1.10
date	2022.08.14.18.59.46;	author root;	state Exp;
branches;
next	1.9;

1.9
date	2022.08.14.18.58.19;	author root;	state Exp;
branches;
next	1.8;

1.8
date	2022.08.13.17.32.42;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2022.08.13.15.56.15;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2022.08.13.14.55.58;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2022.08.12.22.58.25;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2022.08.12.22.57.40;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2022.08.12.22.54.05;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2022.08.11.15.35.35;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2022.08.11.15.30.02;	author root;	state Exp;
branches;
next	;


desc
@@


1.10
log
@*** empty log message ***
@
text
@#include "headers.h"
#include "declarations.h"

ssize_t readDevice(struct file *filep, char __user *u_buff, size_t size, loff_t * temp)
{
	 Dev *ldev;
	 int noctr, nocrd, i, ret;
	 Qset *lqset;
#ifdef DEBUG
        printk(KERN_INFO "%s: Begin\n",__func__);
#endif  
	ldev =(Dev *)filep->private_data;
        if(!ldev)
        {   
                printk(KERN_INFO "%s: ERROR: opened Device Not Found\n",__func__);
                goto OUT;
        }   
    
	//ldev->dataSize > 0 -----> Not go in to sleep
	//ldev->dataSize <= 0 -----> go in to sleep as nothing to raed 
        wait_event_interruptible(ldev->myqueue,ldev->dataSize > 0); 
//      if(ldev->dataSize == 0)
//		wait_for_completion(&ldev->cmplsn);

        if(size > ldev->dataSize)
                size= ldev->dataSize;
        else
                size = size;

	noctr = size;
	nocrd = i = 0;
	lqset = ldev->first;
	
/*	if(down_interruptible(&ldev->sem))         // lock
        {
                return -ERESTARTSYS;
        }*/


	while(size > 0)
        {
                if(noctr > ldev->registerSize)               // size of quntom
                        noctr = ldev->registerSize;
                else
                        noctr = size;

	        ret = copy_to_user(u_buff+nocrd,lqset->data[i], noctr);
                if(ret > 0)
                {
                        printk(KERN_INFO "%s: Partial Read\n",__func__);
                }
                nocrd += (noctr -ret);
               	noctr = size -= (noctr -ret);
		if( i == (ldev->noofRegisters - 1))
                {
                        i =0;
                        lqset = lqset->next;
                }
                else
                        i++;
	}

//	up(&ldev->sem);      // unlock

#ifdef DEBUG
        printk(KERN_INFO "%s: End\n",__func__);
#endif
	return nocrd;
OUT:
#ifdef DEBUG
        printk(KERN_INFO "%s: ERROR: End\n",__func__);
#endif
        return -1;
}
@


1.9
log
@*** empty log message ***
@
text
@d21 1
a21 1
        wait_event_interruptible(ldev->myqueue,ldev->dataSize > 0) 
@


1.8
log
@*** empty log message ***
@
text
@d19 5
a23 2
        if(ldev->dataSize == 0)
		wait_for_completion(&ldev->cmplsn);
@


1.7
log
@*** empty log message ***
@
text
@d19 3
d31 1
a31 1
	if(down_interruptible(&ldev->sem))         // lock
d34 2
a35 1
        }
d60 1
a60 1
	  up(&ldev->sem);      // unlock
@


1.6
log
@*** empty log message ***
@
text
@d28 1
a28 1
	if(down_interruptable(&ldev->sem))         // lock
@


1.5
log
@*** empty log message ***
@
text
@d27 6
d55 2
@


1.4
log
@*** empty log message ***
@
text
@d34 1
a34 1
	        ret = copy_to_user((const void __user *)u_buff+nocrd,lqset->data[i], noctr);
@


1.3
log
@implement read
@
text
@a6 1
	 size_t size;
@


1.2
log
@typo
@
text
@d6 4
d13 11
d25 25
d54 6
a59 1
	return 0;
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
ssize_t readDevice(struct file *filep, char __user *u_buff, size_t size, loff_t * temp);
@
