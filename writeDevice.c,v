head	1.20;
access;
symbols;
locks
	root:1.20; strict;
comment	@ * @;


1.20
date	2022.08.14.18.58.20;	author root;	state Exp;
branches;
next	1.19;

1.19
date	2022.08.13.17.37.29;	author root;	state Exp;
branches;
next	1.18;

1.18
date	2022.08.13.17.32.43;	author root;	state Exp;
branches;
next	1.17;

1.17
date	2022.08.13.15.56.17;	author root;	state Exp;
branches;
next	1.16;

1.16
date	2022.08.13.14.56.00;	author root;	state Exp;
branches;
next	1.15;

1.15
date	2022.08.12.22.56.41;	author root;	state Exp;
branches;
next	1.14;

1.14
date	2022.08.12.22.54.21;	author root;	state Exp;
branches;
next	1.13;

1.13
date	2022.08.12.22.11.27;	author root;	state Exp;
branches;
next	1.12;

1.12
date	2022.08.12.22.04.45;	author root;	state Exp;
branches;
next	1.11;

1.11
date	2022.08.12.21.11.55;	author root;	state Exp;
branches;
next	1.10;

1.10
date	2022.08.12.21.01.14;	author root;	state Exp;
branches;
next	1.9;

1.9
date	2022.08.12.20.55.44;	author root;	state Exp;
branches;
next	1.8;

1.8
date	2022.08.12.20.54.59;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2022.08.12.20.48.24;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2022.08.12.20.44.39;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2022.08.12.19.44.19;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2022.08.12.19.15.11;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2022.08.12.19.13.43;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2022.08.11.20.14.12;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2022.08.11.15.30.03;	author root;	state Exp;
branches;
next	;


desc
@@


1.20
log
@*** empty log message ***
@
text
@#include "headers.h"
#include "declarations.h"

ssize_t writeDevice(struct file *filep, const char __user *u_buff, size_t size, loff_t *temp )
{
	Dev *ldev;
        size_t lsize;
        int i = 0, noctw, nocwn, ret;
        Qset *lqsetp;

#ifdef DEBUG
        printk(KERN_INFO "%s: Begin\n",__func__);
#endif  

        ldev =(Dev *)filep->private_data;
	if(!ldev)
	{
        	printk(KERN_INFO "%s: ERROR: opened Device Not Found\n",__func__);
	        goto OUT;
	}
        
	if(size > ldev->deviceSize)
		lsize= ldev->deviceSize;
	else
		lsize = size;

/*	if(down_interruptible(&ldev->sem))         // lock
        {
                return -ERESTARTSYS;
        }*/

	ldev->first = createScull(lsize);

        i= nocwn =0;
        noctw = lsize;
	lqsetp = ldev->first;
        while(lsize > 0)
	{
		if(noctw > ldev->registerSize)               // size of quntom
			noctw = ldev->registerSize;
		else
			noctw = lsize;

		ret = copy_from_user(lqsetp->data[i], (const void __user *)u_buff+nocwn, noctw);
	   	if(ret > 0)
		{
        		printk(KERN_INFO "%s: Partial write\n",__func__);
		}
		
		nocwn += noctw - ret;
		noctw = lsize -= (noctw - ret);
                if( i == (ldev->noofRegisters - 1))
                {
			i =0;
			lqsetp = lqsetp->next;
		}
		else
			i++;
	}	

       ldev->dataSize = nocwn;

       
       filep->f_pos = *temp;
       wake_up_interruptible(&ldev->myqueue);
//     complete(&ldev->cmplsn);
//     up(&ldev->sem);      // unlock

#ifdef DEBUG
        printk(KERN_INFO "%s: End\n",__func__);
#endif
	return nocwn;
OUT:
#ifdef DEBUG
        printk(KERN_INFO "%s: ERROR: End\n",__func__);
#endif
	return -1;
}
@


1.19
log
@*** empty log message ***
@
text
@d61 1
a61 3
       ldev->dataSize = nocwn;	
//     filep->f_pos = *temp;
       complete(&ldev->cmplsn);
d63 4
@


1.18
log
@*** empty log message ***
@
text
@d63 1
a63 1
       completion(&ldev->cmplsn);
@


1.17
log
@*** empty log message ***
@
text
@d27 1
a27 1
	if(down_interruptible(&ldev->sem))         // lock
d30 1
a30 1
        }
d62 2
d65 1
a65 1
       up(&ldev->sem);      // unlock
a66 1
       
@


1.16
log
@*** empty log message ***
@
text
@d27 1
a27 1
	if(down_interruptable(&ldev->sem))         // lock
@


1.15
log
@typo
@
text
@d27 5
d63 3
@


1.14
log
@*** empty log message ***
@
text
@d39 1
a39 1
		ret = copy_from_user(test, (const void __user *)u_buff+nocwn, noctw);
d56 2
a57 1
       ldev->dadaSize = nocwn;	
@


1.13
log
@*** empty log message ***
@
text
@a5 1
	char test[5];
d55 2
a56 1
 
@


1.12
log
@*** empty log message ***
@
text
@d40 1
a40 1
		ret = copy_to_user(test, (const void __user *)u_buff+nocwn, noctw);
@


1.11
log
@*** empty log message ***
@
text
@a39 5
		printk(KERN_INFO "%s: noctw %d lsize  %ld registerSize %d\n",__func__, noctw, lsize, ldev->registerSize);
		

        	printk(KERN_INFO "%s: user string %s \n",__func__, u_buff+nocwn);
//		ret = copy_to_user(lqsetp->data[i], (const void __user *)u_buff+nocwn, noctw);
a40 2
	   
        	printk(KERN_INFO "%s: copied string %s \n",__func__, test);
d45 1
a47 1
		printk(KERN_INFO "%s: noctw %d nocwn %d ret %d\n",__func__, noctw, nocwn,ret);
a51 1
        		printk(KERN_INFO "%s: only for testing if\n",__func__);
a53 1
		{
a54 2
        		printk(KERN_INFO "%s: only for testing else\n",__func__);
		}
@


1.10
log
@*** empty log message ***
@
text
@d6 1
d9 1
a9 1
        int i, noctw, nocwn, ret;
d44 5
a48 2
		ret = copy_to_user(lqsetp->data[i], u_buff+nocwn, noctw);
	        if(ret > 0)
@


1.9
log
@*** empty log message ***
@
text
@d41 2
@


1.8
log
@*** empty log message ***
@
text
@d39 1
a39 1
		printk(KERN_INFO "%s: noctw %d lsize  %d registerSize %d\n",__func__, noctw, lsize, ldev->registerSize);
@


1.7
log
@*** empty log message ***
@
text
@d39 2
@


1.6
log
@*** empty log message ***
@
text
@a39 1
		printk(KERN_INFO "%s: noctw %d nocwn %d \n",__func__, noctw, nocwn);
d46 1
@


1.5
log
@*** empty log message ***
@
text
@d40 1
d51 1
d54 1
d56 2
@


1.4
log
@typo
@
text
@d44 2
a45 2
		nocwn += (noctw - ret);
		noctw = lsize = lsize - (noctw - ret);
@


1.3
log
@*** empty log message ***
@
text
@d4 1
a4 1
ssize_t writeDevice(struct file *filep, const char __user *U_buff, size_t size, loff_t *temp )
d49 1
a49 1
			lqsetp = lqsetp->nest;
@


1.2
log
@*** empty log message ***
@
text
@d8 2
d29 9
a37 1
	//copy_to_user()
d39 16
d58 1
a58 1
	return 0;
@


1.1
log
@Initial revision
@
text
@d6 3
d13 15
d33 5
@
